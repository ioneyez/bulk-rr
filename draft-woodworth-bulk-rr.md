---
title: BULK DNS Resource Records
abbrev: BULK RR
docname: draft-woodworth-bulk-rr-05
date: 2017-02-15

ipr: trust200902
area: Internet
wg: DNSOP Working Group
kw: Internet-Draft
cat: std
updates: 2308, 4033, 4034, 4035
obsoletes: 222

coding: us-ascii
pi:
  - toc
  - symrefs
  - sortrefs

author:
  -
    ins: J. Woodworth
    name: John Woodworth
    org: CenturyLink, Inc.
    street: 4250 N Fairfax Dr
    city: Arlington
    code: VA 22203
    country: USA
    email: John.Woodworth@CenturyLink.com

  -
    ins: D. Ballew
    name: Dean Ballew
    org: CenturyLink, Inc.
    street: 2355 Dulles Corner Blvd, Ste 200 300
    city: Herndon
    code: VA 20171
    country: USA
    email: Dean.Ballew@CenturyLink.com

  -
    ins: S. Bindinganaveli Raghavan
    name: Shashwath Bindinganaveli Raghavan
    org: Hughes Network Systems
    street: 11717 Exploration Lane
    city: Germantown
    code: MD 20876
    country: USA
    email: shashwath.bindinganaveliraghavan@hughes.com

  -
    ins: D.C. Lawrence
    name: David C Lawrence
    org: Akamai Technologies
    street: 150 Broadway
    city: Cambridge
    code: MA 02142-1054
    country: USA
    email: tale@akamai.com

normative:
  rfc1034:
  rfc1035:
  rfc2119:
  rfc2181:
  rfc2308:
  rfc2317:
  rfc3597:
  rfc4033:
  rfc4034:
  rfc4035:
  rfc5234:

informative:
  rfc7719:
  bind-arm:
    title: BIND 9 Configuration Reference
    author:
      org: Internet Systems Consortium
    date: 2016
    target: https://ftp.isc.org/isc/bind9/cur/9.9/doc/arm/Bv9ARM.html

--- abstract

The BULK DNS resource record type defines a method of pattern-based
creation of DNS resource records.  The intent of BULK is to simplify
generic assignments in a memory-efficient way that can be easily
shared between the primary and secondary nameservers for a zone.
   
--- note_Ed_note

Text inside square brackets (\[\]) is additional background
information, answers to frequently asked questions, general musings,
etc.  They will be removed before publication.  This document is being
collaborated on in GitHub at
\<https://github.com/vttale/bulk-rr\>.  The most recent
version of the document, open issues, etc should all be available
here.  The authors gratefully accept pull requests.

--- middle

# Introduction

The BULK DNS resource record defines a pattern-based method for
on-the-fly resource record generation.  It is essentially an enhanced
wildcard mechanism, constraining generated resource record owner names
to those that match a pattern.  It is also akin to the $GENERATE
master file directive {{bind-arm}} without being limited to numeric
values and without creating all possible records in the zone data.

For example, consider the following record:

~~~~
example.com. 86400 IN BULK A (
                      pool-A-[0-255]-[0-255].example.com.
                      10.55.${1}.${2}
                   )
~~~~

It will answer requests for pool-A-0-0.example.com through
pool-A-255-255.example.com with the IPv4 addresses 10.55.0.0 through
10.55.255.255.

Much larger record sets can be defined while minimizing the associated
requirements for server memory and zone transfer network bandwidth.

DNSSEC support is also described.  The Numeric Pattern Normalization
(NPN) resource record provides a way of generating pattern-based
DNSSEC signatures, and securely performing DNSSEC validation on such
signatures.

## Background and Terminology

ppThe reader is assumed to be familiar with the basic DNS and DNSSEC
concepts described in {{RFC1034}}, {{RFC1035}}, {{RFC4033}},
{{RFC4034}}, and {{RFC4035}}; subsequent RFCs that update them in
{{RFC2181}} and {{RFC2308}}; and DNS terms in {{RFC7719}}.

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in {{RFC2119}}.

# The BULK Resource Record

The BULK resource record enables an authoritative nameserver to
generate RRs for other types based upon the query received.

The Type value for the BULK RR type is TBD.

The BULK RR is class-independent.

## BULK RDATA Wire Format

The RDATA for a BULK RR is as follows:

~~~~
                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Match Type          |                               /
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+       Domain Name Pattern     /
/                                                               /
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/                                                               /
/                      Replacement Pattern                      /
/                                                               /
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
~~~~

Match Type identifies the type of the RRset to be generated by this
BULK record.  It is two octets corresponding to an RR TYPE code as
specified in {{RFC1035}}, Section 3.2.1.

Domain Name Pattern consists of a pattern encoded as a wire-format
fully qualified domain name.  The full name is used so that numeric
substrings above the zone cut can be captured in addition to those in
the zone.  It needs no length indicator for the entire field because
the root label marks its end.

Special characters are interpreted as per the following Augmented
Backus-Naur Form (ABNF) notation from {{RFC5234}}.

~~~~
match         =  1*(range / string)

range         =  "[" decnum "-" decnum "]" /
                  "<" hexnum "-" hexnum ">"
                      ; create references for substitution

string        =  1*(ctext / quoted-char)

decnum        =  1*decdigit

hexnum        =  1*hexdigit

octet         =  %x00-FF

decdigit      =  %x30-39
                      ; 0-9
hexdigit      =  DIGIT / 0x41-0x46 / 0x61-66
                      ; 0-9, A-F, a-f

ctext         =  <any octet excepting "\">

quoted-char   = "\" octet
                       ; to allow special characters as literals
~~~~

\[ Should \[] and <> be allowed as short for \[0-255] and \<00-ff>? \]

Interpretation of the Domain Name Pattern is described in detail in
the "BULK Replacement" section.

Replacement Pattern describes how the answer RRset MUST be generated
for the matching query.  It needs no length indicator because its end
can be derived from the rdata length minus Match Type and Domain Name
Pattern lengths.  It uses the following additional ABNF elements:

~~~~
replace       =   1*(reference / string)

reference     =   "$" "{" (positions / "*") [options] "}"

positions     =   (position / posrange) 0*("," (position / posrange))

posrange      =   position "-" position

position      =   1*decnum

options       =   delimiter [interval [padding]]

delimiter     =   "|" *1(ctext | quoted-char)
                        ; "\|" to use "|" as delimiter
                        ; "\\" to use "\" as delimiter

interval      =   "|" *2DIGIT

padding       =   "|" *2DIGIT

~~~~

\[ Is this complexity beyond simple ${1}, ${2}, etc, really worth
it?  I definitely see how it could make for shorter replacement
patterns, but does it enhance their clarity and usability? \]

## The BULK RR Presentation Format

Match Type is represented as an RR type mnemonic or with {{RFC3597}}'s
generic TYPE mechanism.

Domain Name Pattern is represented as a fully qualified domain name as
per {{RFC1035}} Section 5.1 rules for encoding special and
non-printing characters.

Replacement Pattern is represented by the standard \<character-string>
rules for master files as per {{RFC1035}} section 5.1.

It is suggested that lines longer than 80 characters be wrapped with
parenthetical line continuation, per {{RFC1035}} Section 5.1, starting
after Match Type and ending after Replacement Pattern.

# BULK Replacement

When an authoritative nameserver receives a query for which it does
not have a matching name or a covering wildcard, it MUST then look for
BULK RRs at the zone apex, selecting all BULK RRs with a Match Type
that matches the query type and a Domain Name Pattern that matches the
query name.  Note that query type ANY will select all Match Types, and
all query types match a CNAME Match Type \[ and DNAME? ].  One or more
answer RRs will be generated per the replacement rules below.
Examples are provided in an appendix.

## Matching the Domain Name Pattern

A query name matches the Domain Name Pattern if the characters that
appear outside the numeric ranges match exactly and those within
numeric ranges have values that fall within the range.  Numeric
matches MUST be of the appropriate decimal or hexadecimal type as
specified by the delimiters in the pattern.  For example, if a range
is given as \[0-255], then FF does not match even though its value as
a hexadecimal number is within the range.

When a query name matches a Domain Name Pattern, the value in each
numeric range is stored for use by the Replacement Pattern, with
reference numbers starting at 1 and counting from the left.  For
example, matching the query name host-24-156 against
host-\[0-255]-\[0-255] assigns 24 to ${1} and 156 to ${2}.

## Record Generation using Replacement Pattern

The Replacement Pattern generates the record data by replacing the
${...} references with data captured from the query name, and copying
all other characters literally.

The simplest form of reference uses only the reference number between
the braces, "{" and "}".  The value of the reference is simply
copied directly from the matching position of the query name.

The next form of reference notation uses the asterisk, "*".  With
${*}, all captured values in order of ascending position, delimited by
its default delimiter (described below), are placed in the answer.

Numeric range references, such as ${1-4}, replaces all values captured
by those references, in order, delimited by the default delimiter
described below.  To reverse the order in which they are copied,
reverse the upper and lower values, such as ${4-1}.  This is useful
for generating PTR records from query names in which the address is
encoded in network order.

Similar to range references, separating positions by commas creates
sets for replacement. For example, ${1,4} would be replaced by the
first and fourth captured values, delimited its default delimiter.
This notation may be combined with the numeric range form, such as 
${3,2,1,8-4}.

### Delimiters

A reference can specify a delimiter to use between copied position
values by following a vertical bar, "|", with either zero or one
characters.  \[ Why not any length? \]?  Zero characters, such as in
${1-3|}, means no delimiter is used.  The default delimiter is the
hyphen, "-". \[ Earlier drafts attempted to make the default delimiter
context-dependent, such as by using a period for A requests and a
colon for AAAA requests.  This increases implementation complexity as
an attempt to make things more intuitive for zone administrators.
However it isn't clear that this is a net gain for ease of use. \]

### Delimiter intervals

A second vertical bar in the reference options introduces a delimiter
interval.  The default behavior of a multi-position reference is to
combine each captured value specified with a delimiter between each.
With a delimiter interval the delimiters are only added between every
Nth value.  For example, ${*|-|4} adds a hyphen between every group of
four captured positions.  This can be a handy feature in the IPv6
reverse namespace where every nibble is captured as a separate value
and generated hostnames include sets of 4 nibbles.  An empty or 0
value for the delimiter interval MUST be interpreted as the default
value of 1.

### Padding length

The fourth and final reference option determines the field width of
the copied value.  Shorter values MUST be padded with leading zeroes
("0") and longer values MUST be truncated to the width.

The default behavior, and that of an explicit empty padding length, is
that the captured query name substring is copied exactly.  A width of
zero "0" is a signal to "unpad", and any leading zeros MUST be
removed. \[ Unnecessary complexity? \]

If a delimiter interval greater than 1 is used, captured values
between the intervals will be concatenated and the padding or
unpadding applied as a unit and not individually.  An example of this
would be ${*||4|4} which would combine each range of 4 captured values
and pad or truncate them to a width of 4 characters. 

\[ If this is kept, the element/feature should probably be renamed
from "padding" since it is just as likely to truncate. \]

### Final processing

The TTL of each RR generated by a BULK RR is the TTL of the
corresponding BULK record itself.  \[ BULK should probably have its
own TTL field because using that of the record itself feels like bad
design.  On the other hand, if BULK is never meant to be queried for
directly and only appears in authoritative data, its own TTL is pretty
useless normally. \]

If the generated record type is one that uses domain names in its
resource record data, such as CNAME, any relative domain names MUST be
fully qualified with the origin domain of the BULK RR.

# The NPN Resource Record

The NPN resource record provides pre-processing directives for Numeric
Pattern Normalization (NPN) based RR signature generation.

The Type value for the NPN RR type is XX.

The NPN RR is class independent.

The NPN RR has no special TTL requirements.

## NPN RDATA Wire Format

The RDATA for a NPN RR consists of a 2 octet Match Type field, a 1
octet Flags field, a 1 octet Owner Ignore field, a 1 octet Left Ignore
field and a 1 octet Right Ignore field.

~~~~
                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Match Type          |     Flags     |  Owner Ignore |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Left Ignore  |  Right Ignore |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
~~~~

### The Match Type field

The Match Type field identifies the type of the RRset identified by
this NPN record.

### The Flags field

The Flags field defines additional processing parameters for data
normalization.  This document defines only the Period-As-Number flag
"." (position 5), the Hyphen-As-Number "-" (position 6) and the
hexadecimal flag "X" (position 7).  All other flags are reserved for
future use.

~~~~
 0 1 2 3 4 5 6 7
+-+-+-+-+-+-+-+-+
|Reserved |.|-|X|
+-+-+-+-+-+-+-+-+
~~~~

~~~~
Bits 0-4: Reserved for future
   These flags have no default value if set to false (0).
Bit    5: Period As Number (.) Flag
   This flag indicates the period (dot) will be processed as a
   number. This flag has no default value if set to false (0).
Bit    6: Hyphen As Number (-) Flag
   This flag indicates the hyphen (dash) will be processed as a
   number. This flag has no default value if set to false (0).
Bit    7: Hexadecimal (X) Flag
   This flag indicates the highest value for Normalization Processing
   is "f".  Normalization Processing will be described in a later
   section.  This flag has a default value of 9 if set to false (0).
~~~~

### The Owner Ignore field

The Owner Ignore field defines the length of characters as counted
from the left-hand side of the owner which MUST be ignored by the
normalization process.  This field offers additional security to
pattern based signatures which may not be immediately apparent.  By
restricting the leftmost characters defined by this value, ultimately
the length of the generated portion of the accompanying BULK RR will
be confined accordingly.  Normalization Processing will be described
further in a later section.

### The Left Ignore field

The Left Ignore field defines the length of characters as counted from
the left-hand side of the generated RDATA which MUST be ignored by the
normalization process.  Normalization Processing will be described
further in a later section.

### The Right Ignore field

The Right Ignore field defines the length of characters as counted
from the right-hand side of the generated RDATA which MUST be ignored
by the normalization process.  Normalization Processing will be
described further in a later section.

## The NPN RR Presentation Format

The Match Type field is represented as an RR type mnemonic.  When the
mnemonic is not known, the TYPE representation as described in
{{RFC3597}}, Section 5, MUST be used.

The Flags field MUST be presented as a string of characters
representing each flag bit.  This document defines only the period
".", hyphen "-" and hexadecimal "X" flags.  Flags MAY appear in any
order.  For example; all three flags could appear as "-9." or ".f-"
(without the quotes).  If all bits are zero all default values (if
defined) would be presented ("9" as currently defined).

All Ignore fields MUST be presented as an unsigned decimal integers
and fall within the 0-255 range available to a single octet.

## Normalization Processing of NPN RRs

This document provides a minor yet significant modification to DNSSEC
regarding how RRsets will be signed or verified.  Specifically the
Signature Field of {{RFC4034}}, Section 3.1.8.  Prior to processing into
canonical form, signed zones may contain associated RRs where; owner,
class and type of a non NPN RR directly corresponds with an NPN RR
matching owner, class and Match Type.  If this condition exists the
NPN RR's RDATA defines details for processing the associated RDATA
into a "Normalized" format.  Normalized data is based on pre-canonical
formatting and zero padded for "A" and "AAAA" RR types for acceptable
precision during the process.  This concept will become clearer in the
NPN pseudocode and examples provided in the sections to follow.

The rules for this transformation are simple:

   For RR's Owner field, characters from the beginning to the index of
   the Owner Ignore value or the final string of characters belonging
   to the zone's ORIGIN MUST NOT be modified by this algorithm.  While
   the Owner Ignore value is not used for BULK records but is included
   with the expectation other pattern-based resource records may
   emerge and leverage NPN records for their DNSSEC support
   requirements.

   For RR's RDATA field, character from beginning to the index of Left
   Ignore value or characters with index of Right Ignore value to the
   end MUST NOT be modified by this algorithm.

   In the remaining portion of both Owner and RDATA strings of numeric
   data, defined as character "0" through "f" or "0" through "9"
   depending on whether or not the Hexadecimal flag is set or not,
   MUST be consolidated to a single character and set to the highest
   value defined by the Hexadecimal flag.  Examples may be found in
   the following section.  If period-as-number or hyphen-as-number
   flags are set whichever are used ("." or "-") would be treated as
   part of the number and consolidated where appropriate.

Once the normalization has been performed the signature will continue
processing into canonical form using the normalized RRs in the place
of original ones.

One thing to keep in mind when calculating values for the Ignore
fields is the Domain Name Pattern and Replacement Pattern fields are
considered relative unless terminated by a period.  When processing
NPN records the fully-qualified Patterns will be used for determining
which characters should be ignored.

NPN RRs MAY be included in the "Additional" section to provide a hint
for NPN processing required for verification path.

It is important to note, properly sizing the Ignore fields is critical
to minimizing the risk of spoofed signatures.  Never intentionally set
all Ignore values to zero in order to make validation easier as it
places the validity of zone data at risk. Only accompany RRs which are
pattern derived (such as BULK) with NPN records as doing so may
unnecessarily reduce the confidence level of generated signatures.

### Pseudocode for NPN Normalization Processing

This section provides a simple demonstration of process flow for NPN
rdata normalization and DNSSEC signatures.

The pseudocode provided below assumes all associated RRs are valid
members of a DNSSEC compatible RRset (including BULK generated ones).

~~~~
   for rr in rrset
       if (has_NPN<rr.owner, rr.class, rr.type>)
           rr.rdata_normal = NPN_normalize<rr.rdata>
           add_to_sigrrset<NPN.owner, rr.class, rr.type,
               rr.rdata_normal>
           next
       else
           add_to_sigrrset<rr.owner, rr.class, rr.type, rr.rdata>
           next

   process_canonical_form<sigrrset>

   dnssec_sign<sigrrset>
~~~~

Similar logic MUST be used for determining DNSSEC validity of RRsets
in verification (validation) nameservers for signatures generated
based on NPN normalization.

### NPN Normalization Processing examples

EXAMPLE 1
For this example the query is defined as a PTR record for "10.2.3.44" with an origin of "2.10.in-addr.arpa." and the evaluating BULK and NPN RR as:

~~~~
   -.2.10.in-addr.arpa. 86400 IN BULK PTR (
                                       [0-255].[0-10]
                                       pool-A-${1}-${2}.example.com.
                                       )
   *.2.10.in-addr.arpa. 86400 IN NPN  PTR 9 0 7 13
~~~~

As shown previously in BULK RR examples the query would enter the
nameserver with an owner of "44.3.2.10.in-addr.arpa." and a "PTR" RR
with the RDATA of "pool-A-3-44.example.com." would be generated.

By protecting the "Ignore" characters from the generated RR's RDATA
the focus for normalization becomes "3-44" as illustrated below.

~~~~
                              1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 
          0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6
                        v---------
            p o o l - A - 3 - 4 4 . e x a m p l e . c o m .
                         ---------^
        2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1                  
        6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
~~~~

Everything to the left of "3-44" will remain intact as will everything
to its right.  The remaining characters will be processed for numbers
between "0" and "9" as indicated by the NPN record's hexadecimal flag
"9" and each run replaced by the single character "9".  The final
Normalized RDATA would therefore become "pool-A-9-9.example.com." and
its signature would be based on this "normalized" RDATA field.  This
new "normalized" string would be used as an RDATA for the wildcard
label of "*.2.10.in-addr.arpa." now encompassing all possible
permutations of the "pool-A-${1}-${2}.example.com." pattern.

Since the verification (validation) nameserver would use the identical
NPN record for processing and comparison, all RRs generated by the
BULK record can now be verified with a single wildcard signature.

EXAMPLE 2

This example contains a classless IPv4 delegation on the /22 CIDR
boundary as defined by {{RFC2317}}.  The network for this example is
"10.2.0/22" delegated to a nameserver "ns1.sub.example.com.".  RRs for
this example are defined as:

~~~~
$ORIGIN 2.10.in-addr.arpa.
0-3 86400 IN      NS    ns1.sub.example.com.
-   86400 IN BULK CNAME [0-255].[0-3] ${*|.}.0-3
*   86400 IN NPN  CNAME 9 0 0 23
~~~~

For this example, a query of "10.2.2.65" would enter the nameserver as
"65.2.2.10.in-addr.arpa." and a "CNAME" RR with the RDATA of
"65.2.0-3.2.10.in-addr.arpa." would be generated.

By protecting the "Ignore" characters from the generated RR's RDATA
the focus for normalization becomes "65.2" as illustrated below.

~~~~
                           1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
       v---------
         6 5 . 2 . 0 - 3 . 2 . 1 0 . i n - a d d r . a r p a .
        ---------^
     2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1                  
     9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
~~~~

Everything to the left of "65.2" will remain intact as will everything
to its right.  The remaining characters will be processed for numbers
between "0" and "9" as indicated by the NPN record's hexadecimal flag
"9" and each run replaced by the single character "9".  The final
Normalized RDATA would therefore become "9.9.0-3.2.10.in-addr.arpa."
and its signature would be based on this "normalized" RDATA field.
This new "normalized" string would be used as an RDATA for the
wildcard label of "\*.2.10.in-addr.arpa." now encompassing all possible
permutations of the "${\*|.}.0-3.2.10.in-addr.arpa." pattern.

As in example 1, the verification (validation) nameserver would use
the same NPN record for comparison.

EXAMPLE 3
This example provides reverse logic for example 1 by providing an IPv4
"A" record for a requested hostname.  For this example the query is
defined as an "A" record for "pool-A-3-44.example.com." with an origin
of "example.com.".  RRs for this example are defined as:

~~~~
-.example.com. 86400 IN BULK A (
                                   pool-A-[0-10]-[0-255]
                                   10.2.${*}
                                  )
*.example.com. 86400 IN NPN  A 9 0 8 0
~~~~

By protecting the "Ignore" characters from the generated RR's RDATA
the focus for normalization becomes "003.044" as illustrated below.

~~~~
                                    1 1 1 1 1 1 1 1 1
                0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8
                                v--------------
                  0 1 0 . 0 0 2 . 0 0 3 . 0 4 4
                                 ---------------^
            1 1 1 1 1 1 1 1 1
            8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
~~~~

This example illustrates a key point about NPN records; since they are
pre-canonical they MUST operate on a strict subset of WIRE formatted
data.  For "A" and "AAAA" records this means the "Ignore" fields are
based on zero padded data.  In this example our generated record MUST
be converted into "010.002.003.044" (shown above) prior to processing.
After processing, wire format would become "0x0A02032C" (shown in
hexadecimal).  This format would be too imprecise for normalization so
padded decimal is used.

Everything to the left of "003.044" will remain intact as will
everything to its right.  The remaining characters will be processed
for numbers between "0" and "9" as indicated by the NPN record's
hexadecimal flag "9" and each run replaced by the single character
"9".  The final Normalized RDATA would therefore become "10.2.9.9" and
its signature would be based on this "normalized" RDATA field. This
new "normalized" "A" RR would be used as an RDATA for the wildcard
label of "*.example.com." now encompassing all possible permutations
of the "10.2.${*}" pattern.

EXAMPLE 4
This example provides similar logic for an IPv6 AAAA record.  For this
example the query is defined as an "AAAA" record for
"pool-A-ff-aa.example.com." with an origin of "example.com.".  RRs for
this example are defined as:

~~~~
-.example.com. 86400 IN BULK AAAA (
                                   pool-A-[0-ffff]-[0-ffff]
                                   fc00::${1}:${2}
                                  )
*.example.com. 86400 IN NPN  AAAA X 0 30 0
~~~~

By protecting the "Ignore" characters from the generated RR's RDATA
the focus for normalization becomes "00ff:00aa" as illustrated below.

~~~~
                      1 1 1 1 1 1 1 1 1 1 2 2
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1

    f c 0 0 : 0 0 0 0 : 0 0 0 0 : 0 0 0 0 : -/-/

  4 3 3 3 3 3 3 3 3 3 3 2 2 2 2 2 2 2 2 2 2 1
  0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9
   /-/-/- . . . . . . . . . . . . . . . . . . . . . . . . -/-/-/
                          2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 4
                          1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0
                                            v------------------
                     /-/- 0 0 0 0 : 0 0 0 0 : 0 0 f f : 0 0 a a
                                             -------------------^
                        2 1 1 1 1 1 1 1 1 1 1 
                        0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
~~~~

This example reinforces the point on pre-canonical processing of NPN
records; they MUST operate on a strict subset of WIRE formatted
data. For "A" and "AAAA" records this means the "Ignore" fields are
based on zero padded data.  In this example our generated record MUST
be converted into "fc00:0000:0000:0000:0000:0000:00ff:00aa" (shown
above) prior to processing.  After processing, wire format would
become "0xFC000000000000000000000000FF00AA" (shown in
hexadecimal). This format is slightly misleading as it is truly only
16 bytes of WIRE data and would be too imprecise for normalization so
padded hexadecimal is used.

Everything to the left of "00ff:00aa" will remain intact as will
everything to its right.  The remaining characters will be processed
for numbers between "0" and "f" as indicated by the NPN record's
hexadecimal flag "X" and each run replaced by the single character
"f".  The final Normalized RDATA would therefore become "fc00::f:f"
and its signature would be based on this "normalized" RDATA
field. This new "normalized" "AAAA" RR would be used as an RDATA for
the wildcard label of "*.example.com." now encompassing all possible
permutations of the "fc00::${1}:${2}" pattern.

# Positive Side-Effects

This section highlights positive side effects of some architectural
decisions regarding the BULK RR design.

## Record Superimposition

The main side-effect of the BULK RR design is superimposition.  RRs
created by the BULK generation process generally rely on the logic of
wildcard assignment.  This logic only provides answers where no others
exist.  This means in the reverse DNS world (network assignment) HUGE
blocks of addresses can be assigned a single BULK record and where
delegated to another customer or SWIP will be automatically
overridden.

When compared with BIND's $GENERATE statement, if a singleton record
such as CNAME appears within a $GENERATE range, either the CNAME or
$GENERATE becomes invalid.  While a BULK record range would
automatically notch out the CNAME without user intervention or
creating a potential management problem for the future when two
$GENERATES create a hole where the CNAME no longer exists.  BULK RRs
would again automatically reassign the missing record to one of its
own.

## Pattern Based DNSSEC support

The NPN resource record can be used to support other dynamic RR types
which do not currently exist.

# Known Limitations

This section defines known limitations of the BULK resource type.

## Increased CPU utilization for NXDOMAIN RRs

Nameserver requirements to support BULK RRs will minimally increase
CPU utilization requirements compared to most RR types.  However,
since the inception of DNSSEC more is expected of DNS servers at a
system resource level and it is the authors' belief the benefit
outweighs the sacrifice.

A quick comparison of BULK versus bind's $GENERATE expansion reveals
much more memory would be sacrificed with $GENERATES to save the CPU
cycles required to support BULK records.  Additionally, $GENERATES
cannot be transferred (i.e. AXFR) without expansion and an IPv6 CIDR
even as small as /96 would be simply impossible.  BULK on the other
hand can easily support IPv6 CIDRs of /64 and much larger with very
little effort.

## Pre-Adoption Nameserver Implications

While there is an added demand on authoritative nameservers, there are
no new requirements to recursive (caching) resolvers for non-DNSSEC
record handling.  Even authoritative nameservers are able to transfer
to and from supporting nameservers with no requirement (although would
be unable to return BULK generated records without support).

Prior to widespread adoption on the authoritative side all generated
records would be invisible if served on nameservers lacking
support. Since generated records are generally NOT service impacting
records this should be understood but not of great concern.

Once adoption has reached an appreciable level on the producer
(authoritative) side only DNSSEC requirements remain for the consumer
(resolver) side.  This behavior is fully expected.

# Security Considerations

Two known security considerations exist for the BULK resource record,
DNSSEC and DDOS attack vectors.  Both are addressed in the following
sections.

## DNSSEC Signature Strategies

DNSSEC was designed to provide verification (validation) for DNS
resource records.  In a nutshell this requires each (owner, class,
type) tuple to have its own signature.  This essentially defeats the
purpose of providing large generated blocks of RRs in a single RR as
each generated RR would require its own legitimate RRSIG record.

In the following sections several options are discussed to address
this issue.  Of the options, on-the-fly provides the most secure
solution and NPN provides the most flexible.

### On-the-fly (Live) Signatures

This solution requires authoritative nameservers to sign generated
records _as_they_are_generated_.  Not all authoritative nameserver
implementations offer on-the-fly (realtime) signatures so this
solution would either require all implementations to support
on-the-fly signing or be ignored by implementations which can not or
will not comply.

No changes to recursive (resolving) nameservers is required to support
this solution.

### Normalized (NPN Based) Signatures

This solution provides the most flexible solution as nameservers
without on-the-fly signing capabilities can still support signatures
for BULK records.  The down side to this solution is it requires
DNSSEC aware recursive (resolving) nameserver support.  Unless a
recursive nameserver can verify the signature it is _unverifiable_.

It has been pointed out due to this limitation creation of DNSSEC
signed BULK RRs requiring NPN support SHOULD be formally discouraged
until such time a respectable percentage (>80) of DNSSEC verification
(validation) nameservers "in-the-wild" possess NPN processing
capabilities.  Until that time, on-the-fly signing and unsigned BULK
records offer the intended capabilities of this document while
requiring zero new features to support RR resolution. The authors
would like to encourage opening this door for pattern based
technologies such as NPN records as a solution to BULK RRs as well as
other pattern based RRs to come. Given enough time, enough nameservers
will be patched and upgraded for unrelated reasons and by means of
simple attrition can supply a level of "inertia" and eventually
widespread adoption can be assumed.

NPN records are likely to be a topic of great debate as to their own
security limitations.  It is, however, the authors' belief; while any
logic which limits the input of digital signatures, lessens the
validity of such signatures, the limitation is minimal and the gain is
significant.  The main reason for this is as a general rule, RRs used
in a generic manner such as conventional $GENERATE RRs or scripted
mass pattern generated RRs have a lesser importance than other RRs in
managed zones.  These therefore inherently pose less risk by means of
attack and have a much less reward by defeating security measures.

This being said, care must still be taken to set the Ignore fields
appropriately to minimize exposure and only use NPN RRs to secure
pattern-based records such as BULK.

### Non-DNSSEC Zone Support Only

As a final option zones which wish to remain entirely without DNSSEC
support may serve such zones without either of the above solutions and
records generated based on BULK RRs will require zero support from
recursive (resolving) nameservers.

## DNSSEC Verifier Details

Verification of DNSSEC signed BULK generated RRs may be performed
against on-the-fly signatures with zero modification to their
behavior.  However, verification against NPN records would require
changes to the logic to incorporate processing RDATA generated by BULK
logic as described above so the results will be compatible.

## DDOS Attack Vectors and Mitigation

As an additional defense against Distributed Denial Of Service (DDOS)
attacks against recursive (resolving) nameservers it is highly
recommended shorter TTLs be used for BULK RRs than others.  While
disabling caching with a zero TTL is not recommended (as this would
only result in a shift of the attack target) a balance will need to be
found.  While this document uses 24 hours (86400) in its examples
values between 300 to 900 are likely more appropriate and is
RECOMMENDED.  What is ultimately deemed appropriate may differ from
zone to zone and administrator to administrator.

## Implications of Large Scale DNS Records

The production of such large scale "records in the wild" may have some
unintended side-effects.  These side-effects could be of concern or
add unexpected complications to DNS based security offerings or
forensic and anti-spam measures.  While outside the scope of this
document, implementers of technology relying on DNS resource records
for critical decision making must take into consideration how the
existence of such a volume of records might impact their technology.

Solutions to the "magnitude" problem for BULK generated RRs are
expected be similar if not identical to that of existing wildcard
records, the core difference being the resultant RDATA will be unique
for each requested Domain Name within its scope.

The authors of this document are confident that by careful
consideration, _negative_side-effects_ produced by implementing the
features described in this document _can_be_eliminated_ from any such
service or product.

# IANA Considerations

IANA is requested to assign numbers for two DNS resource record types
identified in this document: BULK and NPN.

# Acknowledgments

This document was created as an extension to the DNS
infrastructure. As such, many people over the years have contributed
to its creation and the authors are appreciative to each of them even
if not thanked or identified individually.

A special thanks is extended for the kindness, wisdom and technical
advice of Robert Whelton (CenturyLink, Inc.) and Gary O'Brien
(Secure64).

--- back

# BULK Examples

## Example 1

~~~~
$ORIGIN 2.10.in-addr.arpa.
@ 86400 IN BULK PTR (
          [0-255].[0-255].[0-255].[0-255].in-addr.arpa.
          pool-${4-1}.example.com.
        )
~~~~

A query received for the PTR of 4.3.2.10.in-addr.arpa will create the
references ${1} through ${4} with the first four labels of the query
name.  The ${4-1} reference in the replacement pattern will then
substitute them in reverse with the default delimiter of hyphen
between every character and no special field width modifications.  The
TTL of the BULK RR is used for the generated record, making the
response:

~~~~
4.3.2.10.in-addr.arpa 86400 IN PTR pool-10-2-3-4.example.com.
~~~~

## Example 2

~~~~
$ORIGIN 2.10.in-addr.arpa.
@ 86400 IN BULK PTR (
          [0-255].[0-255].[0-255].[0-255].in-addr.arpa.
          pool-${2,1|||3}.example.com.
        )
~~~~

Example 2 is similar to Example 1, except that it modifies the
replacement pattern.  The empty option after the first
vertical bar causes no delimiters to be inserted, while the second
empty option that would keep the delimiter interval as 1.  The latter
is relevant because the final value, padding of 3, is applied over
each delimiter interval even when no delimiter is used.  Not all
captures from the substring are required to be used in the response.

The result is that a query for the PTR of 4.3.2.10.in-addr.arpa
generates this response:

~~~~
4.3.2.10.in-addr.arpa 86400 IN PTR pool-003004.example.com.
~~~~

\[ Admittedly you can't do this very effectively without the field
width complexity. Is this sort of name common?  Does it need support?
Admittedly $GENERATE had the feature, but is that reason enough? \]

\[ Change this to a hex matching example? ]

## Example 3

This example contains a classless IPv4 delegation on the /22 CIDR
boundary as defined by {{RFC2317}}.  The network for this example is
"10.2.0/22" delegated to a nameserver "ns1.sub.example.com.". RRs for
this example are defined as:

~~~~
$ORIGIN 2.10.in-addr.arpa.
@    7200 IN BULK CNAME [0-255].[0-3] ${*|.}.0-3
0-3 86400 IN NS ns1.sub.example.com.
~~~~

A query for the PTR of 25.2.2.10.in-addr.arpa is received and the BULK
record with the CNAME Match Type matches all query types.  25 and 2
are captured as references, and joined in the answer by the period
(".") character as a delimiter, with ".0-3" then appended literally
and fully qualified by the origin domain.  The final synthesized
record is:

~~~~
25.2.2.10.in-addr.arpa 7200 IN CNAME 25.2.0-3.2.10.in-addr.arpa.
~~~~

\[ Without $* and options complexity, the pattern to get the same
result is just ${1}.{$2}.0-3 which is not really significantly onerous
to enter, and slightly less arcane looking to comprehend. \]
